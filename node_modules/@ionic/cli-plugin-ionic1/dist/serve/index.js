"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
const helpers_1 = require("../utils/helpers");
const http_server_1 = require("./http-server");
const live_reload_1 = require("./live-reload");
const config_1 = require("./config");
function serve(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const address = args.options['address'] || config_1.DEFAULT_ADDRESS;
        const locallyAccessible = ['0.0.0.0', 'localhost', '127.0.0.1'].includes(address);
        let externalIP = address;
        if (address === '0.0.0.0') {
            // Find appropriate IP to use for cordova to reference
            const availableIPs = cli_utils_1.getAvailableIPAddress();
            if (availableIPs.length === 0) {
                throw new Error(`It appears that you do not have any external network interfaces. ` +
                    `In order to use livereload with emulate you will need one.`);
            }
            externalIP = availableIPs[0].address;
            if (availableIPs.length > 1) {
                args.env.log.warn(`${chalk.bold('Multiple network interfaces detected!')}\n` +
                    'You will be prompted to select an external-facing IP for the livereload server that your device or emulator has access to.\n' +
                    `You may also use the ${chalk.green('--address')} option to skip this prompt.\n`);
                const promptedIp = yield args.env.prompt({
                    type: 'list',
                    name: 'promptedIp',
                    message: 'Please select which IP to use:',
                    choices: availableIPs.map(ip => ip.address)
                });
                externalIP = promptedIp;
            }
        }
        const serverArgs = cli_utils_1.minimistOptionsToArray(args.options);
        args.env.log.info(`Starting server: ${chalk.bold(serverArgs.join(' '))} - Ctrl+C to cancel`);
        const projectConfig = yield args.env.project.load();
        // Setup Options and defaults
        const serverOptions = {
            projectRoot: args.env.project.directory,
            wwwDir: path.join(args.env.project.directory, projectConfig.documentRoot || 'www'),
            address,
            protocol: 'http',
            externalAddress: externalIP,
            port: helpers_1.stringToInt(args.options['port'], config_1.DEFAULT_SERVER_PORT),
            httpPort: helpers_1.stringToInt(args.options['port'], config_1.DEFAULT_SERVER_PORT),
            livereloadPort: helpers_1.stringToInt(args.options['livereload-port'], config_1.DEFAULT_LIVERELOAD_PORT),
            browser: args.options['browser'],
            browseroption: args.options['browseroption'],
            platform: args.options['platform'],
            consolelogs: args.options['consolelogs'] || false,
            serverlogs: args.options['serverlogs'] || false,
            nobrowser: args.options['nobrowser'] || false,
            nolivereload: args.options['nolivereload'] || false,
            noproxy: args.options['noproxy'] || false,
            lab: args.options['lab'] || false,
            iscordovaserve: args.options['iscordovaserve'] || false,
        };
        // Clean up args based on environment state
        try {
            const portResults = yield Promise.all([
                cli_utils_1.findClosestOpenPort(serverOptions.address, serverOptions.port),
                cli_utils_1.findClosestOpenPort(serverOptions.address, serverOptions.livereloadPort),
            ]);
            serverOptions.port = serverOptions.httpPort = portResults[0];
            serverOptions.livereloadPort = portResults[1];
        }
        catch (e) {
            if (e !== cli_utils_1.ERROR_NETWORK_ADDRESS_NOT_AVAIL) {
                throw e;
            }
            throw new cli_utils_1.FatalException(`${chalk.green(serverOptions.address)} is not available--cannot bind.`);
        }
        // Start up server
        const settings = yield setupServer(args.env, serverOptions);
        const localAddress = 'http://localhost:' + serverOptions.port;
        const externalAddress = 'http://' + serverOptions.externalAddress + ':' + serverOptions.port;
        const externallyAccessible = localAddress !== externalAddress;
        args.env.log.info(`Development server running\n` +
            (locallyAccessible ? `Local: ${chalk.bold(localAddress)}\n` : '') +
            (externallyAccessible ? `External: ${chalk.bold(externalAddress)}\n` : ''));
        if (locallyAccessible && !serverOptions.nobrowser) {
            const openOptions = [localAddress]
                .concat(serverOptions.lab ? [config_1.IONIC_LAB_URL] : [])
                .concat(serverOptions.browseroption ? [serverOptions.browseroption] : [])
                .concat(serverOptions.platform ? ['?ionicplatform=', serverOptions.platform] : []);
            const opn = yield Promise.resolve().then(function () { return require('opn'); });
            opn(openOptions.join(''));
        }
        return Object.assign({ publicIp: serverOptions.externalAddress, localAddress: 'localhost', locallyAccessible,
            externallyAccessible }, settings);
    });
}
exports.serve = serve;
function setupServer(env, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const liveReloadBrowser = yield live_reload_1.createLiveReloadServer(options);
        yield http_server_1.createHttpServer(env, options);
        const chokidar = yield Promise.resolve().then(function () { return require('chokidar'); });
        const projectConfig = yield env.project.load();
        if (!projectConfig.watchPatterns) {
            projectConfig.watchPatterns = [];
        }
        const watchPatterns = [...new Set([...projectConfig.watchPatterns, ...config_1.WATCH_PATTERNS])];
        env.log.debug(() => `Watch patterns: ${watchPatterns.map(v => chalk.bold(v)).join(', ')}`);
        const watcher = chokidar.watch(watchPatterns, { cwd: env.project.directory });
        env.events.emit('watch:init');
        watcher.on('change', (filePath) => {
            env.log.info(`[${new Date().toTimeString().slice(0, 8)}] ${chalk.bold(filePath)} changed`);
            liveReloadBrowser([filePath]);
            env.events.emit('watch:change', filePath);
        });
        watcher.on('error', (err) => {
            env.log.error(err.toString());
        });
        return options;
    });
}
