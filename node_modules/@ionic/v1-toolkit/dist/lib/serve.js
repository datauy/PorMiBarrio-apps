"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_fs_1 = require("@ionic/utils-fs");
const chalk = require("chalk");
const path = require("path");
const dev_server_1 = require("./dev-server");
const gulp_1 = require("./gulp");
const log_1 = require("./log");
exports.WATCH_PATTERNS = [
    'scss/**/*',
    'www/**/*',
    '!www/lib/**/*',
    '!www/**/*.map',
];
function proxyConfigToMiddlewareConfig(proxy) {
    const config = {
        pathRewrite: { [proxy.path]: '' },
        target: proxy.proxyUrl,
    };
    if (proxy.proxyNoAgent) {
        config.agent = false; // TODO: type issue
    }
    if (proxy.rejectUnauthorized === false) {
        config.secure = false;
    }
    return config;
}
exports.proxyConfigToMiddlewareConfig = proxyConfigToMiddlewareConfig;
const DEFAULT_PROXY_CONFIG = {
    changeOrigin: true,
    logLevel: 'warn',
    ws: true,
};
async function runServer(options) {
    let reloadfn;
    if (options.livereload) {
        reloadfn = await dev_server_1.createLiveReloadServer({ host: options.host, port: options.livereloadPort, wwwDir: options.wwwDir });
    }
    await createHttpServer(options);
    const chokidar = await Promise.resolve().then(() => require('chokidar'));
    const watcher = chokidar.watch(options.watchPatterns);
    watcher.on('change', async (filePath) => {
        process.stdout.write(`${log_1.timestamp()} ${chalk.bold(filePath)} changed\n`);
        if (path.extname(filePath) === '.scss') {
            await gulp_1.runTask('sass');
        }
        else {
            if (reloadfn) {
                reloadfn([filePath]);
            }
        }
    });
    watcher.on('error', (err) => {
        process.stderr.write(`${log_1.timestamp()} Error in file watcher: ${err.stack ? err.stack : err}\n`);
    });
    return options;
}
exports.runServer = runServer;
/**
 * Create HTTP server
 */
async function createHttpServer(options) {
    const express = await Promise.resolve().then(() => require('express'));
    const app = express();
    /**
     * http responder for /index.html base entrypoint
     */
    const serveIndex = async (req, res) => {
        // respond with the index.html file
        const indexFileName = path.join(options.wwwDir, 'index.html');
        let indexHtml = await utils_fs_1.readFile(indexFileName, { encoding: 'utf8' });
        indexHtml = dev_server_1.injectDevServerScript(indexHtml);
        if (options.livereload) {
            indexHtml = dev_server_1.injectLiveReloadScript(indexHtml, options.livereloadPort);
        }
        res.set('Content-Type', 'text/html');
        res.send(indexHtml);
    };
    const serveCordovaPlatformResource = async (req, res, next) => {
        if (options.engine !== 'cordova' || !options.platform) {
            return next();
        }
        const resourcePath = path.resolve('platforms', options.platform, 'platform_www');
        if (await utils_fs_1.pathExists(path.join(resourcePath, req.url))) {
            res.sendFile(req.url, { root: resourcePath });
        }
        else {
            next();
        }
    };
    app.get('/', serveIndex);
    app.use('/', (req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        next();
    });
    app.use('/', express.static(options.wwwDir));
    // Cordova
    app.get('/cordova.js', serveCordovaPlatformResource, serveMockCordovaJS);
    app.get('/cordova_plugins.js', serveCordovaPlatformResource);
    app.get('/plugins/*', serveCordovaPlatformResource);
    const livereloadUrl = `http://localhost:${options.livereloadPort}`;
    const pathPrefix = `/${dev_server_1.DEV_SERVER_PREFIX}/tiny-lr`;
    await attachProxy(app, { ...DEFAULT_PROXY_CONFIG, mount: pathPrefix, target: livereloadUrl, pathRewrite: { [pathPrefix]: '' } });
    for (const proxy of options.proxies) {
        await attachProxy(app, { ...DEFAULT_PROXY_CONFIG, ...proxy });
        process.stdout.write(`${log_1.timestamp()} Proxy created ${chalk.bold(proxy.mount)} => ${proxy.target ? chalk.bold(proxy.target) : '<no target>'}\n`);
    }
    app.get(`/${dev_server_1.DEV_SERVER_PREFIX}/dev-server.js`, await dev_server_1.createDevServerHandler(options));
    const wss = await dev_server_1.createDevLoggerServer(options.host, options.devPort);
    return new Promise((resolve, reject) => {
        const httpserv = app.listen(options.port, options.host);
        wss.on('error', err => {
            reject(err);
        });
        httpserv.on('error', err => {
            reject(err);
        });
        httpserv.on('listening', () => {
            resolve(app);
        });
    });
}
async function attachProxy(app, config) {
    const proxyMiddleware = await Promise.resolve().then(() => require('http-proxy-middleware'));
    app.use(config.mount, proxyMiddleware(config.mount, config));
}
function serveMockCordovaJS(req, res) {
    res.set('Content-Type', 'application/javascript');
    res.send('// mock cordova file during development');
}
